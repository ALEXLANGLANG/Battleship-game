package edu.duke.xs75.battleship;


import java.io.IOException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.function.Function;
import java.util.Random;

/**
 * This is the computer player class
 */
public class ComputerPlayer extends BasicPlayer {
  protected int[] counter;
  protected Random rand;

  /**
   * This constructs a textPlayer
   */
  public ComputerPlayer(String name, Board<Character> b, PrintStream out, AbstractShipFactory<Character> shipFactory) {
    super(name,b,out,shipFactory);
    this.counter = new int[] { 3, 3 };
    this.rand = new Random();
  }

  public ComputerPlayer(String name, Board<Character> b, PrintStream out, AbstractShipFactory<Character> shipFactory, int randomSeed) {
    this(name,b,out,shipFactory);
    this.rand.setSeed(randomSeed);
  }

  /**
   * THIS genenrate a coordinate randomly
   * 
   * @return a coordinate generated by Random
   */
  protected Coordinate generateACoord() {
    int w = theBoard.getWidth();
    int h = theBoard.getHeight();
    int r = rand.nextInt(h);
    int c = rand.nextInt(w);
    return new Coordinate(r, c);
  }

  /**
   * This handles the placement to place the ship
   * @param types   is the number of how to place the ship. 2 (v,h)or 4(u,d,l,r)
   * @return a Placement that users input
   */
  protected Placement readPlacement(int types) throws IOException {
    char orientation;
    if (types == 4) {
      orientation = 'U';
    } else {
      orientation = 'H';
    }
    return new Placement(generateACoord(), orientation, types);
  }

  /**
   * This handles the operation to add a ship to the board it will read
   * a line from users and parse it as a placement and print it out
   * @param shipName is the name of the ship
   * @param createFn is the functioin to create a makeShip function
   */
  protected void doOnePlacement(String shipName, Function<Placement, Ship<Character>> createFn) throws IOException {
    String res = " ";
    int types = 2;
    while (res != null) {
      try {
        if (shipName == "Battleship" || shipName == "Carrier") {
          types = 4;
        }
        Placement p = readPlacement(types);
        Ship<Character> s = createFn.apply(p);
        res = theBoard.tryAddShip(s);
      } catch (IllegalArgumentException illegalArg) {
      }
    }
  }

  /**
   * This mainly handles all phase a player needs
   */
  @Override
  public void doPlacementPhase() throws IOException {
    for (int i = 0; i < shipsToPlace.size(); i++) {
      doOnePlacement(shipsToPlace.get(i), shipCreationFns.get(shipsToPlace.get(i)));
    }
  }

  /**
   * This handles the Coordinate to attack the ship, after users input It will be
   * used in Player's turn to do attacking
   * 
   * @throws IOExpection if coordinate is out of bounds
   * @return a Placement that users input
   */
  protected Coordinate readCoordinate() throws IOException {
    return generateACoord();
  }

  /**
   * This choose an action from F, M, S.
   * @return a char F,M or S  
*/

  protected char readActions() throws IOException {
    String act = "F";
    int res = rand.nextInt(20);
    if (res <= 8) {
      act = "M";
    } else if (res >= 12) {
      act = "S";
    }
    act = act.toUpperCase();
    char s = act.charAt(0);
    return s;
  }

  /**
   * This enables player to play one turn: select a coordinate to fire at and
   * display the result to the player after the attacking.
   * @param enemyBoard is enemy board
   * @param enemyView  is the enemy boardview
   */
  @Override
  public void playOneTurn(Board<Character> enemyBoard, BoardTextView enemyView, String myheader, String enemyHeader)
      throws IOException {
    String res = "Invalid action.";
    while (res != null) {
      try {
        char s = readActions();
        if (s == 'F') {
          res = tryFireAShip(enemyBoard);
        } else if (counter[0] > 0 && s == 'M') {
          res = tryMoveShip();
        } else if (counter[1] > 0 && s == 'S') {
          res = tryScanShips(enemyBoard);
        }
        if (res == null && s == 'M') {
          counter[0]--;
        } else if (res == null && s == 'S') {
          counter[1]--;
        }
      } catch (IllegalArgumentException illegalArg) {
        res = "Invalid action.";
      }
    }

  }


  /**
   * this tries to move one ship in my own board to another
   * 
   * @return null if succeed, an error string otherwise.
   */
  protected String tryMoveShip() throws IOException {
    int types = 2;
    Ship<Character> toAdd = null;
    HashMap<Coordinate, Character> masksToAdd = null;
    // remove ship
    Coordinate where = readCoordinate();
    Ship<Character> toRemove = theBoard.findShip(where);
    HashMap<Coordinate, Character> masksToRemove = theBoard.getMasks(toRemove.getCoordinates());
    theBoard.removeShip(toRemove);
    // try to Add the new ship, if fails, add the original ship back
    try {
      String shipName = toRemove.getName();
      if (shipName == "Carrier" || shipName == "Battleship") {
        types = 4;
      }
      Function<Placement, Ship<Character>> createFn = shipCreationFns.get(shipName);
      Placement p = readPlacement(types);
      toAdd = createFn.apply(p);
      toAdd.copyInfoFrom(toRemove);
      masksToAdd = theBoard.getMasks(toAdd.getCoordinates());
      String res = theBoard.tryAddShip(toAdd);
      if (res != null) {
        throw new IllegalArgumentException(res);
      }
    } catch (IllegalArgumentException illegalArg) {
      theBoard.tryAddShip(toRemove);
      return illegalArg + " Go back to menu again.\n";
    }

    theBoard.addMaskToEnemyBoard(masksToAdd);
    theBoard.addMaskToEnemyBoard(masksToRemove);
    out.println("Player " + this.name + " used a special action.\n");
    return null;
  }

  /**
   * Try to use sonar to scan an area in enemy's board
   * 
   * @param enemyBoard is the enemy's board
   * @return null if succeed, a error string otherwise
   */

  protected String tryScanShips(Board<Character> enemyBoard) throws IOException {
    out.println("Player " + this.name + " used a special action.\n");
    return null;
  }

  /**
   * Try to fire a ship on enemyBoard
   * 
   * @param enemyBoard is the enemy's board
   * @return null if succeed, a error string otherwise
   */
  protected String tryFireAShip(Board<Character> enemyBoard) throws IOException {
    Coordinate where = null;
    where = readCoordinate();
    Ship<Character> ship = enemyBoard.fireAt(where);
    if (ship == null) {
      out.println("Player " + this.name + " missed!\n");
    } else {
      out.println("Player " + this.name + " hit a " + ship.getName() + "!\n");
    }
    return null;
  }

}
